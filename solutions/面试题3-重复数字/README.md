# 题目假设
- 数组长度为n
- 数组内数字的范围是[0, n-1]
# 直觉
- 两种方法：排序后遍历，hash
- 直觉的方法没有利用到题目的假设，所以一定存在第三种解决方案
# 重要问题

## 特殊情况

## 边界条件

# 解决方案
- 遍历数组
- 比较item与index的大小关系
    - 如果相等，继续执行
    - 如果不等，交换list[index], list[item]两者的位置
- 如果list[index], list[item]相等，返回

# 解决方法可行性
因为item的范围是[0, n-1]所以list[item]是可行的

# 数据结构
数组
# 复杂度
## 时间复杂度
- 排序遍历
    - list.sort()使用timsort
    - 时间复杂度为nlogn
- hash
    - 数组一次遍历，时间复杂度为n
- 交换位置
    - 数组一次遍历，时间复杂度为n
## 空间复杂度
- 排序遍历
    - 中间变量与入参大小无关，空间复杂度为s(1)
- hash
    - 需要产生一个最坏情况为n-1的hashset
    - 空间复杂度为s(n)
- 交换位置
    - 数组一次遍历，时间复杂度为n
    - 中间变量与入参大小无关，空间复杂度为s(1)

